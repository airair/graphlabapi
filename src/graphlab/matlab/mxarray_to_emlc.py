#!/bin/python
# Reads in the type file generated by emlc and creates an mxArray to emlc types converter
import sys
import fileinput





def output_parser_header(typesheader):
  print "#ifndef MXARRAY_TO_EMLC_HPP"
  print "#define MXARRAY_TO_EMLC_HPP"
  print "#include <mex.h>"
  print "#include \"mexutil.hpp\""
  print "#include \"%s\"" % typesheader
  print
  print "template <typename EMXType>"
  print "struct converter {"
  print "  static void clearemx(EMXType &emxdata) { }"
  print "  static void freeemx(EMXType &emxdata) { }"
  print "  static bool mxarray2emx(const mxArray* mx, EMXType &emxdata) {"
  print "    return false;"
  print "  }"
  print "  static bool emx2mxarray(EMXType &emxdata, mxArray* &mx) {"
  print "    return false;"
  print "  }"
  print "  static void emxcopy(EMXType &dest, const EMXType &src) {"
  print "    assert(false);"
  print "  }"
  print "};"
  print "#include \"struct_arrays.hpp\""
  print "#include \"scalar_converters.hpp\""
  
def output_parser_footer():
  print "template <typename EMXType>"
  print "void clearemx(EMXType &emxdata) { converter<EMXType>::clearemx(emxdata); }"
  print
  print "template <typename EMXType>"
  print "void freeemx(EMXType &emxdata) {converter<EMXType>::freeemx(emxdata); }"
  print
  print "template <typename EMXType>"
  print "bool mxarray2emx(const mxArray* mx, EMXType &emxdata) {"
  print "  return converter<EMXType>::mxarray2emx(mx, emxdata);"
  print "}"
  print
  print "template <typename EMXType>"
  print "bool emx2mxarray(EMXType &emxdata, mxArray* &mx) {"
  print "  return converter<EMXType>::emx2mxarray(emxdata, mx);"
  print "}"
  print
  print "template <typename EMXType>"
  print "void emxcopy(EMXType &dest, const EMXType &src) {"
  print "  converter<EMXType>::emxcopy(dest, src);"
  print "}"
  
  print "#endif"
#enddef



# generate the forward and backward parsers for standard emx types
def generate_standard_emxparser(structname, datatype):
  print "template <>"
  print "struct converter<%s> {" % (structname)
  print "  static void clearemx(%s &emxdata) {" % (structname)
  print "    clear_array<%s,%s>(emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static void freeemx(%s &emxdata) {" % (structname)
  print "    if (!emxdata.canFreeData) return;"
  print "    if (emxdata.data) free(emxdata.data);"
  print "    if (emxdata.size) free(emxdata.size);"
  print "    emxdata.canFreeData = 0;"
  print "  }"
  print "  static bool mxarray2emx(const mxArray* mx, %s &emxdata) {" % (structname)
  print "    return read_array<%s,%s>(mx, emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static bool emx2mxarray(%s &emxdata, mxArray* &mx) {" % (structname)
  print "    return write_array<%s,%s>(emxdata, mx);" % (datatype, structname)
  print "  }"
  print
  print "  static void emxcopy(%s &dest, const %s &src) {" % (structname, structname)
  print "    copy_array<%s,%s>(dest, src);" % (datatype, structname)
  print "  }"
  print "};"
  print
#enddef

# generate the forward and backward parsers for struct emx types
def generate_struct_emxparser(structname, datatype):
  print "template <>"
  print "struct converter<%s> {" % (structname)
  print "  static void clearemx(%s &emxdata) {" % (structname)
  print "    clear_struct_array<%s,%s>(emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static void freeemx(%s &emxdata) {" % (structname)
  print "    free_struct_array<%s,%s>(emxdata);" % (datatype, structname)
  print "  }"
  print "  static bool mxarray2emx(const mxArray* mx, %s &emxdata) {" % (structname)
  print "    return read_struct_array<%s,%s>(mx, emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static bool emx2mxarray(%s &emxdata, mxArray* &mx) {" % (structname)
  print "    return write_struct_array<%s,%s>(emxdata, mx);" % (datatype, structname)
  print "  }"
  print "  static void emxcopy(%s &dest, const %s &src) {" % (structname, structname)
  print "    copy_struct_array<%s,%s>(dest, src);" % (datatype, structname)
  print "  }"
  print "};"
  print
#enddef

def generate_emxparser(structname, datatype):
  # if the datatype ends with '_T' it is a standard type
  if (datatype[-2:] == '_T'):
    generate_standard_emxparser(structname, datatype)
  else:
    generate_struct_emxparser(structname, datatype)
  #endif
#enddef


# generate the forward and backward parsers for all other structs
def generate_structparser(structname, parse):
  # output the clearer
  print "template <>"
  print "struct converter<%s> {" % (structname)

  # output the emxarray to mxarray converter
  print "  static void clearemx(%s &emxdata) {" % (structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    emxdata.%s = (%s*)malloc(sizeof(%s));" % (declname, decltype, decltype)
        print "    converter<%s>::clearemx(*(emxdata.%s));" % (decltype, declname)
      else:
        #scalar!
        print "    converter<%s>::clearemx(emxdata.%s);" % (decltype, declname)
      #endif
  #endfor
  print "  }"
  
  # output the freeer
  
  # output the emxarray to mxarray converter
  print "  static void freeemx(%s &emxdata) {" % (structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    converter<%s>::freeemx(*(emxdata.%s));" % (decltype, declname)
        print "    free(emxdata.%s);" % (declname)
      #endif
  #endfor
  print "  }"
  
  
  # output the mxarray to emxarray converter
  print "  static bool mxarray2emx(const mxArray* mx, %s &emxdata) {" % (structname)
  print "    clearemx(emxdata);";
  print "    bool ret = true;"
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # make sure that this is variable sized or is a scalar
      # i.e. declname has no square brackets
      if (declname.find("[") != -1):
        # fault!!
        sys.stderr.write("field " + declname + " in struct " + structname + " is not variable size\n")
        return 1
      #endif
        

      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    ret &= converter<%s>::mxarray2emx(struct_has_field(mx, \"%s\"), *(emxdata.%s));" % (decltype, declname, declname)
      elif decltype[-2:] == '_T':
        #scalar!
        print "    if (struct_has_field(mx, \"%s\") != NULL) ";
        print "      emxdata.%s = (%s)mxGetScalar(struct_has_field(mx, \"%s\"));" % (declname, decltype, declname);
      else:
        # single struct!
        print "    ret &= converter<%s>::mxarray2emx(struct_has_field(mx, \"%s\"), emxdata.%s);" % (decltype, declname, declname)
      #endif
  #endfor
  print "    return ret;";
  print "  }"
  print
  
  # output the emxarray to mxarray converter
  print "  static bool emx2mxarray(%s &emxdata, mxArray* &mx) {" % (structname)
  print "    bool ret = true;"
  print "    mwSize dims[1];"
  print "    dims[0] = 1;"
  print "    mx = mxCreateStructArray(1,dims,0,NULL);"
  print "    mxArray* mxarr = NULL;";
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    mxarr = NULL;";
        print "    ret &= converter<%s>::emx2mxarray(*(emxdata.%s), mxarr);" % (decltype, declname)
        print "    mxAddField(mx, \"%s\");" % declname
        print "    mxSetField(mx, 0, \"%s\", mxarr);" % declname
      elif decltype[-2:] == '_T':
        #scalar!
        print "    mxarr = NULL;";
        print "    mxarr = mxCreateDoubleScalar(emxdata.%s);" % (declname)
        print "    mxAddField(mx, \"%s\");" % declname
        print "    mxSetField(mx, 0, \"%s\", mxarr);" % declname
      else:
        # single struct
        print "    mxarr = NULL;";
        print "    ret &= converter<%s>::emx2mxarray(emxdata.%s, mxarr);" % (decltype, declname)
        print "    mxAddField(mx, \"%s\");" % declname
        print "    mxSetField(mx, 0, \"%s\", mxarr);" % declname
      #endif
  #endfor
  print "    return ret;";
  print "  }"
  
  #output the copier
  print "  static void emxcopy(%s &dest, const %s &src) {" % (structname, structname)
  print "    freeemx(dest);"
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    converter<%s>::emxcopy(*(dest.%s), *(src.%s));" % (decltype, declname,declname)
      elif decltype[-2:] == '_T':
        #scalar!
        print "    dest.%s = src.%s;" % (declname, declname)
      else:
        # single struct
        print "    converter<%s>::emxcopy(dest.%s, src.%s);" % (decltype, declname, declname)
      #endif
  #endfor
  print "  }"
  print "};"
  print
  print 
  

  return 0
#enddef


def generate_parser(p):
  structname = p["structname"]
  # emxArray__common is not used. do nothing
  if (structname == "emxArray__common"):
    return
  #endif
  
  # if it is an emxArray, we need to build a parser for it
  if (structname[0:8] == "emxArray"):
    print "/*****************    emxArray: " , structname, "    ****************/"
    # what is the datatype?
    # search in the declarations for the data type
    datatype = ""
    for j in p["decls"]:
      if (j["declname"] == "*data"):
        datatype = j["decltype"]
        break
      #endif
    #endfor
    generate_emxparser(structname, datatype);
  else:
    print  "/*****************    Struct: ", structname, "    ****************/"
    generate_structparser(structname, p)
  #endif
#enddef



# -------------------   Main --------------------------


_PY3 = sys.version_info[0] > 2

if _PY3:
    from pyparsing_py3 import Word, Literal, alphas, alphanums, OneOrMore, Group
else:
    from pyparsing_py2 import Word, Literal, alphas, alphanums, OneOrMore, Group


# construct the parser
c_typedef = Literal("typedef")
c_struct = Literal("struct")
c_name = Word( alphas+"_*", alphanums+"_[]" )
c_type = Word( alphas+"_", alphanums+"_" )
c_type2 = c_type ^ ("struct" + c_type)
c_openbrace = Literal("{")
c_closebrace = Literal("}")
c_semicolon = Literal(";")

c_declaration = (c_type.setResultsName("decltype") + c_name.setResultsName("declname") + c_semicolon) ^ \
                ("struct" + c_type.setResultsName("decltype") + c_name.setResultsName("declname") + c_semicolon)
c_declarations = OneOrMore(Group(c_declaration)).setResultsName("decls")
c_structdef = c_typedef + c_struct + c_name.setResultsName("structname") + \
           c_openbrace + c_declarations + c_closebrace + c_name + c_semicolon




if (len(sys.argv) < 2):
  print "Usage: mxarray_to_emlc.py [typesfile] > mxarray_to_emlc.hpp"
  quit()
#endif

# read the input file
f = ""
for line in fileinput.input():
  f = f + line + "\n"
#end for
# run the parser
scn = c_structdef.scanString(f)

# output the header
output_parser_header(sys.argv[1])
# output the body
ret = 0;
for data,dataStart,dataEnd in scn:
  t = generate_parser(data)
  if (t == 1): ret = 1;
#endfor
# output the footer
output_parser_footer()
if (ret != 0):
  sys.exit(ret)
#endif
