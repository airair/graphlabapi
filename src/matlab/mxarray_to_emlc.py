#!/bin/python
# Reads in the type file generated by emlc and creates an mxArray to emlc types converter
import sys
import fileinput





def output_parser_header(typesheader):
  print "#ifndef MXARRAY_TO_EMLC_HPP"
  print "#define MXARRAY_TO_EMLC_HPP"
  print "#include <mex.h>"
  print "#include \"mexutil.hpp\""
  print "#include \"%s\"" % typesheader
  print
  print "template <typename EMXType>"
  print "void clearemx(EMXType &emxdata) { }"
  print
  print "template <typename EMXType>"
  print "void freeemx(EMXType &emxdata) { }"
  print
  print "template <typename EMXType>"
  print "bool mxarray2emx(const mxArray* mx, EMXType &emxdata) {"
  print "\treturn false;"
  print "}"
  print
  print "template <typename EMXType>"
  print "bool emx2mxarray(EMXType &emxdata, mxArray* &mx) {"
  print "\treturn false;"
  print "}"
  print
  print "#include \"struct_arrays.hpp\""
  print "#include \"scalar_converters.hpp\""
  
def output_parser_footer():
  print "#endif"
#enddef



# generate the forward and backward parsers for standard emx types
def generate_standard_emxparser(structname, datatype):
  print "template <>"
  print "void clearemx<%s>(%s &emxdata) {" % (structname, structname)
  print "\t clear_array<%s,%s>(emxdata);" % (datatype, structname)
  print "}"
  print
  print "template <>"
  print "void freeemx<%s>(%s &emxdata) {" % (structname, structname)
  print "\tif (!emxdata.canFreeData) return;"
  print "\tif (emxdata.data) free(emxdata.data);"
  print "\tif (emxdata.size) free(emxdata.size);"
  print "\temxdata.canFreeData = 0;"
  print "}"
  print "template <>"
  print "bool mxarray2emx<%s>(const mxArray* mx, %s &emxdata) {" % (structname, structname)
  print "\t return read_array<%s,%s>(mx, emxdata);" % (datatype, structname)
  print "}"
  print
  print "template <>"
  print "bool emx2mxarray<%s>(%s &emxdata, mxArray* &mx) {" % (structname, structname)
  print "\t return write_array<%s,%s>(emxdata, mx);" % (datatype, structname)
  print "}"
  print
#enddef

# generate the forward and backward parsers for struct emx types
def generate_struct_emxparser(structname, datatype):
  print "template <>"
  print "void clearemx<%s>(%s &emxdata) {" % (structname, structname)
  print "\t clear_struct_array<%s,%s>(emxdata);" % (datatype, structname)
  print "}"
  print
  print "template <>"
  print "void freeemx<%s>(%s &emxdata) {" % (structname, structname)
  print "\t free_struct_array<%s,%s>(emxdata);" % (datatype, structname)
  print "}"
  print "template <>"
  print "bool mxarray2emx<%s>(const mxArray* mx, %s &emxdata) {" % (structname, structname)
  print "\t return read_struct_array<%s,%s>(mx, emxdata);" % (datatype, structname)
  print "}"
  print
  print "template <>"
  print "bool emx2mxarray<%s>(%s &emxdata, mxArray* &mx) {" % (structname, structname)
  print "\t return write_struct_array<%s,%s>(emxdata, mx);" % (datatype, structname)
  print "}"
  print
#enddef

def generate_emxparser(structname, datatype):
  # if the datatype ends with '_T' it is a standard type
  if (datatype[-2:] == '_T'):
    generate_standard_emxparser(structname, datatype)
  else:
    generate_struct_emxparser(structname, datatype)
  #endif
#enddef


# generate the forward and backward parsers for all other structs
def generate_structparser(structname, parse):
  # output the clearer
  
  # output the emxarray to mxarray converter
  print "template <>"
  print "void clearemx<%s>(%s &emxdata) {" % (structname, structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "\temxdata.%s = (%s*)malloc(sizeof(%s));" % (declname, decltype, decltype)
        print "\tclearemx<%s>(*(emxdata.%s));" % (decltype, declname)
      else:
        #scalar!
        print "\tclearemx<%s>(emxdata.%s);" % (decltype, declname)
      #endif
  #endfor
  print "}"
  
  # output the freeer
  
  # output the emxarray to mxarray converter
  print "template <>"
  print "void freeemx<%s>(%s &emxdata) {" % (structname, structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "\tfreeemx(emxdata.%s);" % (declname)
        print "\tfree(emxdata.%s);" % (declname)
      #endif
  #endfor
  print "}"
  
  
  # output the mxarray to emxarray converter
  print "template <>"
  print "bool mxarray2emx<%s>(const mxArray* mx, %s &emxdata) {" % (structname, structname)
  print "\tclearemx(emxdata);";
  print "\tbool ret = true;"
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # make sure that this is variable sized or is a scalar
      # i.e. declname has no square brackets
      if (declname.find("[") != -1):
        # fault!!
        sys.stderr.write("field " + declname + " in struct " + structname + " is not variable size\n")
        return 1
      #endif
        

      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "\tret &= mxarray2emx<%s>(struct_has_field(mx, \"%s\"), *(emxdata.%s));" % (decltype, declname, declname)
      else:
        #scalar!
        print "\tif (struct_has_field(mx, \"%s\") != NULL) ";
        print "\t\temxdata.%s = (%s)mxGetScalar(struct_has_field(mx, \"%s\"));" % (declname, decltype, declname);
      #endif
  #endfor
  print "\treturn ret;";
  print "}"
  print
  
  # output the emxarray to mxarray converter
  print "template <>"
  print "bool emx2mxarray<%s>(%s &emxdata, mxArray* &mx) {" % (structname, structname)
  print "\tbool ret = true;"
  print "\tmwSize dims[1];"
  print "\tdims[0] = 1;"
  print "\tmx = mxCreateStructArray(1,dims,0,NULL);"
  print "\tmxArray* mxarr = NULL;";
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "\tmxarr = NULL;";
        print "\tret &= emx2mxarray<%s>(*(emxdata.%s), mxarr);" % (decltype, declname)
        print "\tmxAddField(mx, \"%s\");" % declname
        print "\tmxSetField(mx, 0, \"%s\", mxarr);" % declname
      else:
        #scalar!
        print "\tmxarr = NULL;";
        print "\tmxarr = mxCreateDoubleScalar(emxdata.%s);" % (declname)
        print "\tmxAddField(mx, \"%s\");" % declname
        print "\tmxSetField(mx, 0, \"%s\", mxarr);" % declname
      #endif
  #endfor
  print "\treturn ret;";
  print "}"
  print 
  

  return 0
#enddef


def generate_parser(p):
  structname = p["structname"]
  # emxArray__common is not used. do nothing
  if (structname == "emxArray__common"):
    return
  #endif
  
  # if it is an emxArray, we need to build a parser for it
  if (structname[0:8] == "emxArray"):
    print "/*****************    emxArray: " , structname, "    ****************/"
    # what is the datatype?
    # search in the declarations for the data type
    datatype = ""
    for j in p["decls"]:
      if (j["declname"] == "*data"):
        datatype = j["decltype"]
        break
      #endif
    #endfor
    generate_emxparser(structname, datatype);
  else:
    print  "/*****************    Struct: ", structname, "    ****************/"
    generate_structparser(structname, p)
  #endif
#enddef



# -------------------   Main --------------------------


_PY3 = sys.version_info[0] > 2

if _PY3:
    from pyparsing_py3 import Word, Literal, alphas, alphanums, OneOrMore, Group
else:
    from pyparsing_py2 import Word, Literal, alphas, alphanums, OneOrMore, Group


# construct the parser
c_typedef = Literal("typedef")
c_struct = Literal("struct")
c_name = Word( alphas+"_*", alphanums+"_[]" )
c_type = Word( alphas+"_", alphanums+"_" )
c_type2 = c_type ^ ("struct" + c_type)
c_openbrace = Literal("{")
c_closebrace = Literal("}")
c_semicolon = Literal(";")

c_declaration = (c_type.setResultsName("decltype") + c_name.setResultsName("declname") + c_semicolon) ^ \
                ("struct" + c_type.setResultsName("decltype") + c_name.setResultsName("declname") + c_semicolon)
c_declarations = OneOrMore(Group(c_declaration)).setResultsName("decls")
c_structdef = c_typedef + c_struct + c_name.setResultsName("structname") + \
           c_openbrace + c_declarations + c_closebrace + c_name + c_semicolon




if (len(sys.argv) < 2):
  print "Usage: mxarray_to_emlc.py [typesfile] > mxarray_to_emlc.hpp"
  quit()
#endif

# read the input file
f = ""
for line in fileinput.input():
  f = f + line + "\n"
#end for
# run the parser
scn = c_structdef.scanString(f)

# output the header
output_parser_header(sys.argv[1])
# output the body
ret = 0;
for data,dataStart,dataEnd in scn:
  t = generate_parser(data)
  if (t == 1): ret = 1;
#endfor
# output the footer
output_parser_footer()
if (ret != 0):
  sys.exit(ret)
#endif
